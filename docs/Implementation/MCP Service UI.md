# **UI Implementation Plan for Log Monitor**

## **1\. Overview and Objectives**

This document provides a comprehensive implementation plan for building the User Interface (UI) for the Log Monitor application. The goal is to create an intuitive, responsive, and informative UI that effectively visualizes the data and insights generated by the backend systems, particularly the Modular AI Processing Service.

The UI will be a single-page application (SPA) built with **React**, served by a dedicated **Flask** backend. This Flask backend will act as a "Backend-for-Frontend" (BFF), aggregating data from the Modular AI Processing Service API and the main PostgreSQL database before serving it to the React client.

### **Key Objectives**

* **Implement a Full-Stack UI Application**: Create a decoupled React/Flask application as defined in the architecture.md document.  
* **Visualize AI Insights**: Build dashboards and views to clearly display anomalies, service health, and agent performance from the Modular AI Processing Service.  
* **Provide Contextual Navigation**: Enable seamless workflows, such as clicking an anomaly to view the exact logs that triggered it.  
* **Enable System Management**: Create interfaces for managing AI models and viewing system status.  
* **Optimize for Target Platform**: Ensure the UI is lightweight and performs well when served from a Raspberry Pi 5\.

## **2\. Prerequisites and Setup**

This plan assumes the Modular AI Processing Service, PostgreSQL database, and Redis are running and accessible on the Docker network as defined in the project's docker-compose.yml files.

### **2.1. Backend (Flask) Project Setup**

1. **Directory Structure**: Within the main log-monitor project, the backend will reside in /backend.  
2. **Dependencies (/backend/requirements.txt)**:  
   Plaintext  
   Flask==2.3.2  
   Flask-CORS==4.0.0 \# For development  
   python-dotenv==1.0.0  
   requests==2.31.0 \# To call the mcp\_service API  
   gunicorn==21.2.0 \# For production

3. **Initialization**: Create a standard Flask application factory in /backend/app/\_\_init\_\_.py.

### **2.2. Frontend (React) Project Setup**

1. **Directory Structure**: The frontend will reside in /frontend.  
2. **Bootstrapping**: Use Vite for a fast, modern development environment.  
   Bash  
   npm create vite@latest frontend \-- \--template react  
   cd frontend

3. **Dependencies (/frontend/package.json)**:  
   Bash  
   npm install react-router-dom axios bootstrap react-bootstrap recharts date-fns

4. **Component Structure**:  
   /frontend/src/  
   ├── components/    \# Reusable UI components (e.g., charts, tables)  
   ├── pages/         \# Top-level page components (Dashboard, LogExplorer)  
   ├── services/      \# API client logic (e.g., api.js)  
   ├── hooks/         \# Custom React hooks  
   └── App.jsx        \# Main router setup

## ---

**Phase 1: Backend API Development (Flask BFF)**

The Flask backend's primary role is to securely fetch, aggregate, and provide data to the React frontend. It will expose its own set of UI-specific API endpoints.

### **1.1. Service Communication Layer**

Create a service module (/backend/app/services/mcp\_api\_client.py) to handle all communication with the Modular AI Processing Service.

Python

\# /backend/app/services/mcp\_api\_client.py  
import requests  
import os

MCP\_SERVICE\_URL \= os.getenv("MCP\_SERVICE\_URL", "http://mcp-service:5555")  
HEALTH\_TOKEN \= os.getenv("HEALTH\_TOKEN")

def get\_mcp\_health():  
    headers \= {'Authorization': f'Bearer {HEALTH\_TOKEN}'}  
    response \= requests.get(f"{MCP\_SERVICE\_URL}/health", headers=headers)  
    response.raise\_for\_status()  
    return response.json()

def get\_mcp\_anomalies(limit=50, offset=0):  
    headers \= {'Authorization': f'Bearer {HEALTH\_TOKEN}'}  
    params \= {'limit': limit, 'offset': offset}  
    response \= requests.get(f"{MCP\_SERVICE\_URL}/api/v1/anomalies", headers=headers, params=params)  
    response.raise\_for\_status()  
    return response.json()

### **1.2. API Endpoints**

Define API blueprints in /backend/app/api/ui\_routes.py.

* **GET /api/ui/dashboard**: Provides aggregated data for the main dashboard.  
  * **Action**: Calls get\_mcp\_health() and get\_mcp\_anomalies() and combines their results. Fetches device health stats (CPU/Memory) if available.  
  * **Response**:  
    JSON  
    {  
      "serviceStatus": {"status": "healthy"},  
      "recentAnomalies": \[...\],  
      "deviceHealth": {"cpuUsage": 25.5, "memoryUsage": 45.1}  
    }

* **GET /api/ui/logs**: Fetches raw logs from the PostgreSQL database for the Log Explorer.  
  * **Action**: Directly queries the log\_entries table. Supports filtering via query parameters (start\_time, end\_time, program, severity).  
  * **Response**: A JSON array of log entries.  
* **GET /api/ui/models**: Lists all available models.  
  * **Action**: Requires an enhancement to the mcp\_service. This Flask endpoint will call a new GET /api/v1/models endpoint on the mcp\_service which lists metadata for all models in the /app/models directory.  
  * **Response**: A JSON array of model metadata objects.  
* **POST /api/ui/models/activate**: Activates a specific model.  
  * **Action**: Proxies a request to a new POST /api/v1/models/activate endpoint on the mcp\_service, which will be responsible for updating the symbolic link.  
  * **Request Body**: {"version": "YYYYMMDD\_HHMMSS"}  
  * **Response**: {"status": "success"}

## ---

**Phase 2: Frontend Implementation (React)**

### **2.1. API Service (/frontend/src/services/api.js)**

Create a centralized module for making API calls to the Flask backend.

JavaScript

import axios from 'axios';  
const apiClient \= axios.create({ baseURL: '/api/ui' });

export const getDashboardData \= () \=\> apiClient.get('/dashboard');  
export const getLogs \= (params) \=\> apiClient.get('/logs', { params });  
export const getModels \= () \=\> apiClient.get('/models');  
export const activateModel \= (version) \=\> apiClient.post('/models/activate', { version });

### **2.2. Routing (/frontend/src/App.jsx)**

Set up the main application routes using react-router-dom.

JavaScript

import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';  
import DashboardPage from './pages/DashboardPage';  
import LogExplorerPage from './pages/LogExplorerPage';  
import ModelManagementPage from './pages/ModelManagementPage';

function App() {  
  return (  
    \<Router\>  
      {/\* Add a Navbar/Sidebar component here \*/}  
      \<Routes\>  
        \<Route path\="/" element\={\<DashboardPage /\>} /\>  
        \<Route path\="/logs" element\={\<LogExplorerPage /\>} /\>  
        \<Route path\="/models" element\={\<ModelManagementPage /\>} /\>  
      \</Routes\>  
    \</Router\>  
  );  
}

### **2.3. Dashboard Page (/frontend/src/pages/DashboardPage.jsx)**

This page will implement the "AI Analysis Center" concept.

* **Layout**: Use a grid layout for multiple panels.  
* **Components**:  
  * StatusPanel.jsx: Displays data from serviceStatus and deviceHealth. Uses simple text and gauges/charts from recharts.  
  * AnomalyFeed.jsx: Displays recentAnomalies. Each item should be a Link from react-router-dom.  
* **Data Fetching**: Use a useEffect hook to call getDashboardData on component mount. Use setInterval to poll for fresh data every 30 seconds.  
* **Contextual Link Example**:  
  JavaScript  
  // Inside AnomalyFeed.jsx map function  
  const logViewerUrl \= \`/logs?start=\<span class="math-inline"\>\\{anomaly\\.startTime\\}\&end\\=\</span\>{anomaly.endTime}\&program=${anomaly.program}\`;  
  return \<Link to\={logViewerUrl}\>{anomaly.description}\</Link\>;

### **2.4. Log Explorer Page (/frontend/src/pages/LogExplorerPage.jsx)**

An interactive view for deep-diving into logs.

* **Components**:  
  * LogFilterBar.jsx: Contains date pickers and text inputs for filtering. Manages filter state.  
  * LogTable.jsx: Displays the filtered logs in a paginated table.  
* **Data Flow**:  
  1. The page reads initial filter values from the URL query parameters using the useSearchParams hook from react-router-dom.  
  2. A useEffect hook listens for changes to the filter state (or initial URL parameters) and calls the getLogs API service with the current filters.  
  3. The returned data is rendered in LogTable.

### **2.5. Model Management Page (/frontend/src/pages/ModelManagementPage.jsx)**

An interface for managing AI models.

* **Components**:  
  * ModelListTable.jsx: Fetches and displays data from getModels. Each row should show model metadata and have an "Activate" button.  
  * UploadModelForm.jsx (Future Enhancement): A form to upload new models.  
* **Actions**: The "Activate" button will call the activateModel API service, show a confirmation toast, and refetch the model list to show the new "active" model.

## ---

**Phase 3: Testing and Deployment**

### **3.1. Testing Strategy**

* **Backend**: Use pytest to write unit tests for each API endpoint in the Flask BFF. Mock the requests calls to the mcp\_service.  
* **Frontend**: Use React Testing Library to write component tests. Mock the axios calls to ensure components render correctly with sample data.

### **3.2. Deployment**

1. **Build React App**: Run npm run build in the /frontend directory. This creates a static dist folder.  
2. **Configure Flask to Serve React**: Configure the Flask backend to serve the index.html from the React build for all non-API routes and serve the static assets (/assets/\*).  
3. **Dockerize**: The Flask application (now including the static UI files) is containerized.  
4. **Nginx**: An Nginx reverse proxy will route requests for /api/ui/\* to the Flask container and all other requests to the React frontend served by Flask, as outlined in architecture.md.

This implementation plan provides a clear, phase-based path to developing a robust and feature-rich UI that effectively leverages the backend services while adhering to the project's core architectural principles.  
